import csv
import time
import requests
import subprocess
import openpyxl
import xml.etree.ElementTree as ET

#
# README
# Prerequisities:
#   apt-get install libopenscap8
#   pip3 install openpyxl
#
# How to use:
# python3 ethcvescan.py
# Report files will be usaved under /tmp/ 
# 

#
# Oscap
# 
class Oscap:

    OSCAP_DIRECTIVES = "/tmp/oscap-directives.xml"
    OSCAP_RESULTS    = "/tmp/oscap-results.xml"
    NS = {"res": "http://oval.mitre.org/XMLSchema/oval-results-5",
          "def": "http://oval.mitre.org/XMLSchema/oval-definitions-5"}

    # __intit__
    def __init__(self):
        self.critCVEs = {}
        self.highCVEs = {}
        self.critPatches = {}
        self.highPatches = {}
        self.tree = None
        self.root = None

    # eval
    def eval(self):
        # save a file called directive.xml in /tmp with the following content
        with open(self.OSCAP_DIRECTIVES, "w") as f:
            f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            f.write('<oval_directives xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5" xmlns:oval-res="http://oval.mitre.org/XMLSchema/oval-results-5" xmlns="http://oval.mitre.org/XMLSchema/oval-directives-5" xsi:schemaLocation="http://oval.mitre.org/XMLSchema/oval-results-5 oval-results-schema.xsd http://oval.mitre.org/XMLSchema/oval-common-5 oval-common-schema.xsd http://oval.mitre.org/XMLSchema/oval-directives-5 oval-directives-schema.xsd">\n')
            f.write('    <generator>')
            f.write('         <oval:product_name>OpenSCAP</oval:product_name>\n')
            f.write('         <oval:schema_version>5.8</oval:schema_version> <!-- make sure the OVAL version matches your input -->\n')
            f.write('         <oval:timestamp>2017-02-04T00:00:00</oval:timestamp>\n')
            f.write('    </generator>\n')
            f.write('    <directives include_source_definitions="true">\n')
            f.write('        <oval-res:definition_true reported="true" content="thin"/>\n')
            f.write('        <oval-res:definition_false reported="false" content="thin"/>\n')
            f.write('        <oval-res:definition_unknown reported="true" content="thin"/>\n')
            f.write('        <oval-res:definition_error reported="true" content="thin"/>\n')
            f.write('        <oval-res:definition_not_evaluated reported="true" content="thin"/>\n')
            f.write('        <oval-res:definition_not_applicable reported="true" content="thin"/>\n')
            f.write('    </directives>\n')
            f.write('</oval_directives>\n')
            f.close()
        
        rel = self.__exec("lsb_release -cs")
        
        print("Downloading OVAL file for Ubuntu "+rel+"...")
        self.__exec("rm -f /tmp/com.ubuntu."+rel+".usn.oval.xml.bz2")
        self.__exec("wget -O /tmp/com.ubuntu."+rel+".usn.oval.xml.bz2 https://security-metadata.canonical.com/oval/com.ubuntu."+rel+".usn.oval.xml.bz2")
        
        print("Uncompressing OVAL file for Ubuntu "+rel+"...")
        self.__exec("rm -f /tmp/com.ubuntu."+rel+".usn.oval.xml")
        self.__exec("bunzip2 /tmp/com.ubuntu."+rel+".usn.oval.xml.bz2")
        
        print("OSCAP eval for Ubuntu "+rel+"...")
        cmdEval = "oscap oval eval --directives "+self.OSCAP_DIRECTIVES+" --results "+self.OSCAP_RESULTS+" /tmp/com.ubuntu."+rel+".usn.oval.xml"
        cmdCode = self.__exec(cmdEval)

    # parse
    def parse(self):
        # parse the file oscap-results.xml
        self.tree = ET.parse(self.OSCAP_RESULTS)
        self.root = self.tree.getroot()

        # iterate over all the defintions with result="true"
        for definition in self.root.findall('./res:results/res:system/res:definitions/res:definition[@result="true"]', self.NS):
            definition_id = definition.get('definition_id')
            for definition in self.root.findall(f'./def:oval_definitions/def:definitions/def:definition[@id="{definition_id}"]', self.NS):
                
                # iterate over all the elements with cvss_severity="critical"
                for cve_element in definition.findall('./def:metadata/def:advisory/def:cve[@cvss_severity="critical"]', self.NS):
                    # save the CVE ID and definition_id in the dictionary self.critCVEs
                    self.critCVEs[cve_element.text] = definition_id
                    if definition_id in self.critPatches:
                        self.critPatches[definition_id] = self.critPatches[definition_id] + ", " + cve_element.text
                    else:
                        self.critPatches[definition_id] = cve_element.text

                # iterate over all the elements with cvss_severity="high"
                for cve_element in definition.findall('./def:metadata/def:advisory/def:cve[@cvss_severity="high"]', self.NS):
                    # save the CVE ID and definition_id in the dictionary self.highCVEs
                    self.highCVEs[cve_element.text] = definition_id
                    if definition_id in self.highPatches:
                        self.highPatches[definition_id] = self.highPatches[definition_id] + ", " + cve_element.text
                    else:
                        self.highPatches[definition_id] = cve_element.text

    # get_critical_CVEs
    def get_critical_CVEs(self):
        return self.critCVEs
    
    # get_high_CVEs
    def get_high_CVEs(self):
        return self.highCVEs

    # get_critical_patches
    def get_critical_patches(self):
        return self.critPatches
    
    # get_high_patches
    def get_high_patches(self):
        return self.highPatches

    # get_definition
    def get_definition(self, definition_id):
        # iterate over all the defintions with id=definition_id
        result = {}
        for definition in self.root.findall(f'./def:oval_definitions/def:definitions/def:definition[@id="{definition_id}"]', self.NS):
            # return the definition
            result['id'] = definition.get('id')
            result['class'] = definition.get('class')
            result['title'] = definition.find('./def:metadata/def:title', self.NS).text
            result['description'] = definition.find('./def:metadata/def:description', self.NS).text
            for reference in definition.findall('./def:metadata/def:reference[@source="USN"]', self.NS):
                result['notice_id'] = reference.get("ref_id")
                result['notice_url'] = reference.get("ref_url")
        return result

    # get_cve
    def get_cve(self, cve_id):
        # iterate over all the defintions with id=definition_id
        result = {}
        for cve in self.root.findall(f'./def:oval_definitions/def:definitions/def:definition/def:metadata/def:advisory/def:cve[@href="https://ubuntu.com/security/{cve_id}"]', self.NS):
            # return the definition
            result['id']       = cve_id
            result['url']      = cve.get('href')
            result['priority'] = cve.get('priority')
            break
        return result

    # __exec
    def __exec(self, command):
        try:
            # Execute the command and capture the output
            output = subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT, text=True)
            if output is not None:
                output = output.strip()
            return output
        except subprocess.CalledProcessError as e:
            print(f"Command '{command}' returned non-zero exit status {e.returncode}.")
            raise e
        except Exception as e:
            print(f"An error occurred: {str(e)}")
            raise e


#
# Mitre
# 
class Mitre:
    MITRE_API_KEY = "218c750a-cbb6-42de-86b0-7d02b7318177"
    MITRE_TIME_DELAY = 10

    # get_cve
    def get_cve(self, cve_id):
        # get the CVE from the MITRE API
        url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        
        # make a GET request to the URL with cveId as a query parameter and apiKey as a header
        response = requests.get(url, {"cveId":cve_id}, headers={"api_key":self.MITRE_API_KEY})
        if response.status_code != 200:
            print("Error: "+str(response.status_code)+response.text)
            return None
        
        cve = {}
        cveJson = response.json()
        cve['id']                = cveJson['vulnerabilities'][0]['cve']['id']
        cve['url']               = "https://nvd.nist.gov/vuln/detail/"+cve_id
        cve['description']       = cveJson['vulnerabilities'][0]['cve']['descriptions'][0]['value']
        cve['cvss_vectorString'] = cveJson['vulnerabilities'][0]['cve']['metrics']['cvssMetricV31'][0]['cvssData']['vectorString']
        cve['cvss_score']        = cveJson['vulnerabilities'][0]['cve']['metrics']['cvssMetricV31'][0]['cvssData']['baseScore']
        cve['cvss_severity']     = cveJson['vulnerabilities'][0]['cve']['metrics']['cvssMetricV31'][0]['cvssData']['baseSeverity']
        
        # iterate over the cpeMatch elements
        # "criteria": "cpe:2.3:a:google:protobuf-java:*:*:*:*:*:*:*:*"
        for cpeMatch in cveJson['vulnerabilities'][0]['cve']['configurations'][0]['nodes'][0]['cpeMatch']:
            criteria = cpeMatch['criteria'].split(":")
            cpe = criteria[3]+":"+criteria[4]
            if 'versionEndExcluding' in cpeMatch:
                cpe = cpe +":"+cpeMatch['versionEndExcluding']+"\n"
            else:
                cpe = cpe +"\n"
        cve['cpe'] = cpe

        # sleep for MITRE API rate limit
        time.sleep(self.MITRE_TIME_DELAY)
        return cve


#
# CveReport
# 
class CveReport:
    ETH_CVE_REPORT_CSV  = "/tmp/eth-cve-report.csv"
    ETH_CVE_REPORT_XLSX = "/tmp/eth-cve-report.xlsx"
    ETH_CVE_REPORT_HEADERS = ["CVE", "CVSS Score", "Severity", "CVSS Vector", 
                              "Vulnerable component", "NIST URL", "Description", 
                              "Ubuntu URL", "Ubuntu Priority", 
                              "Definition ID", "Notice ID", "Definition Title", "Definition Class", 
                              "Notice URL", "Definition Description",
                              "Assessment Level", "Remediation Level"]

    def __init__(self):
        self.table = []
    
    # Function to add a row to the table
    def add_cve(self, 
                cve, cvss_score, cvss_severity, cvss_vector,
                cpe, cve_nist_url, cve_descrition,
                cve_ubnt_url, cve_ubnt_priority, 
                def_id, notice_id, def_title, def_class, 
                notice_url, def_description,
                assessment_level, remediation_level):
        self.table.append([
                            cve, cvss_score, cvss_severity, cvss_vector,
                            cpe, cve_nist_url, cve_descrition,
                            cve_ubnt_url, cve_ubnt_priority,
                            def_id, notice_id, def_title, def_class, 
                            notice_url, def_description,
                            assessment_level, remediation_level
                        ])

    # Function to sort the table by a specific column
    def sort_by_cvss(self):
        # sort the self.table by the column 1 (CVSS Score) descending (reverse=True)
        self.table.sort(key=lambda x: x[1], reverse=True)

    # Function to print the table in CSV format
    def save_csv(self):
        with open(self.ETH_CVE_REPORT_CSV, 'w', newline='') as csvfile:
            csv_writer = csv.writer(csvfile)
            csv_writer.writerow(self.ETH_CVE_REPORT_HEADERS)
            for row in self.table:
                csv_writer.writerow(row)

    # function to print the table in excel format
    def save_excel(self):
        workbook = openpyxl.Workbook()
        sheet = workbook.active
        sheet.append(self.ETH_CVE_REPORT_HEADERS)
        for row in self.table:
            sheet.append(row)

        workbook.save(self.ETH_CVE_REPORT_XLSX)
        workbook.close()


#
# PatchReport
# 
class PatchReport:
    ETH_PATCH_REPORT_CSV  = "/tmp/eth-patch-report.csv"
    ETH_PATCH_REPORT_XLSX = "/tmp/eth-patch-report.xlsx"
    ETH_PATCH_REPORT_HEADERS = ["Definition ID", "Notice ID", "Definition Title", "Definition Class", 
                                "Notice URL", "CVE IDs", "CVSS Severity", "Definition Description"]

    def __init__(self):
        self.table = []
    
    # Function to add a row to the table
    def add_patch(self, 
                  def_id, notice_id, def_title, def_class, 
                  notice_url, cves, cvss_severity, def_description):
        self.table.append([
                            def_id, notice_id, def_title, def_class, 
                            notice_url, cves, cvss_severity, def_description
                          ])

    # Function to print the table in CSV format
    def save_csv(self):
        with open(self.ETH_PATCH_REPORT_CSV, 'w', newline='') as csvfile:
            csv_writer = csv.writer(csvfile)
            csv_writer.writerow(self.ETH_PATCH_REPORT_HEADERS)
            for row in self.table:
                csv_writer.writerow(row)

    # function to print the table in excel format
    def save_excel(self):
        workbook = openpyxl.Workbook()
        sheet = workbook.active
        sheet.append(self.ETH_PATCH_REPORT_HEADERS)
        for row in self.table:
            sheet.append(row)

        workbook.save(self.ETH_PATCH_REPORT_XLSX)
        workbook.close()


#
# main
#
mitre = Mitre()
cveReport = CveReport()
patchReport = PatchReport()

# run oscap and evaluate the results for the current Ubuntu version
oscap = Oscap()
oscap.eval()
oscap.parse()

print("CVE Report")

# for each critical CVE ID, add it to the report
for cve_id in oscap.get_critical_CVEs():
    print("Critical: "+cve_id)
    cveNist = mitre.get_cve(cve_id)
    if cveNist is None:
        print("NIST CVE not found: "+cve_id)
        continue
    
    cveUbnt = oscap.get_cve(cve_id)
    definition = oscap.get_definition(oscap.get_critical_CVEs()[cve_id])
    cveReport.add_cve(cveNist['id'], cveNist['cvss_score'], cveNist['cvss_severity'], cveNist['cvss_vectorString'],
                      cveNist['cpe'], cveNist['url'], cveNist['description'],
                      cveUbnt['url'], cveUbnt['priority'], 
                      definition['id'], definition['notice_id'], definition['title'], definition['class'], 
                      definition['notice_url'], definition['description'],
                      "", "")

# for each high CVE ID, add it to the report
for cve_id in oscap.get_high_CVEs():
    print("High: "+cve_id)
    cveNist = mitre.get_cve(cve_id)
    if cveNist is None:
        print("NIST CVE not found: "+cve_id)
        continue
    
    cveUbnt = oscap.get_cve(cve_id)
    definition = oscap.get_definition(oscap.get_high_CVEs()[cve_id])
    cveReport.add_cve(cveNist['id'], cveNist['cvss_score'], cveNist['cvss_severity'], cveNist['cvss_vectorString'],
                      cveNist['cpe'], cveNist['url'], cveNist['description'],
                      cveUbnt['url'], cveUbnt['priority'], 
                      definition['id'], definition['notice_id'], definition['title'], definition['class'], 
                      definition['notice_url'], definition['description'],
                      "", "")

cveReport.sort_by_cvss()
cveReport.save_csv()
cveReport.save_excel()

print("Patch Report")

# for each critical patch, add it to the report
for def_id in oscap.get_critical_patches():
    print("Critical: "+def_id)
    definition = oscap.get_definition(def_id)
    patchReport.add_patch(definition['id'], definition['notice_id'], definition['title'], definition['class'], 
                          definition['notice_url'], oscap.get_critical_patches()[def_id], "Critical", definition['description'])

# for each high patch, add it to the report
for def_id in oscap.get_high_patches():
    print("High: "+def_id)
    definition = oscap.get_definition(def_id)
    patchReport.add_patch(definition['id'], definition['notice_id'], definition['title'], definition['class'], 
                          definition['notice_url'], oscap.get_high_patches()[def_id], "High", definition['description'])

patchReport.save_csv()
patchReport.save_excel()


